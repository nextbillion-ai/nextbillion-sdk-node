// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { Metadata, asTextContentResult } from 'nextbillion-sdk-mcp/tools/types';

import { Tool } from '@modelcontextprotocol/sdk/types.js';
import NextbillionSDK from 'nextbillion-sdk';

export const metadata: Metadata = {
  resource: 'fleetify.routes',
  operation: 'write',
  tags: [],
  httpMethod: 'post',
  httpPath: '/fleetify/routes',
  operationId: 'routes',
};

export const tool: Tool = {
  name: 'create_fleetify_routes',
  description:
    "When using this tool, always use the `jq_filter` parameter to reduce the response size and improve performance.\n\nOnly omit if you're sure you don't need the data.\n\nDispatch a new route",
  inputSchema: {
    type: 'object',
    properties: {
      key: {
        type: 'string',
        description: 'A key is a unique identifier that is required to authenticate a request to the API.',
      },
      driver_email: {
        type: 'string',
        description:
          'Specify the e-mail address of the driver who should receive the route. The e-mail address must be registered in [NextBillion.ai Cloud Console](https://console.nextbillion.ai/).',
      },
      steps: {
        type: 'array',
        description:
          'An array of objects to collect the details about the intermediate steps in the route to be dispatched. Each object corresponds to a single step. The array must begin with a start-type step and end with an end-type step, to form a valid route.',
        items: {
          $ref: '#/$defs/route_steps_request',
        },
      },
      distance: {
        type: 'integer',
        description:
          "Specify the total distance, in meters, for an informative display in Driver's app. The distance specified here has no effect on the actual route that the service generates.",
      },
      document_template_id: {
        type: 'string',
        description:
          'Specify the ID of the document template that should be used to collect proof of completion for all steps in the route. In order to complete each route step, the driver will need to submit a form generated by the rules defined in the given document template. Use the [Documents API](https://docs.nextbillion.ai/docs/dispatches/documents-api) to create, read and manage document templates.\n\nPlease note that the document template ID assigned to a route does not apply to following step types - `start`, `end`, `break`, `layover`.',
      },
      ro_request_id: {
        type: 'string',
        description:
          "Specify the Route Optimization request ID. When this ID is provided, all other fields will be ignored (including the required fields) and the route optimization result will be used to form the routes and corresponding steps.\n\nPlease note that:\n\n*   The driver's email ID must be provided in input `vehicle.metadata` as `user_email` such that the route optimization result must contain a valid driver email, step's arrival time, etc., to make a successful dispatch.\n    \n*   Document Template for collecting proof of delivery or completion can not be specified when using this field to dispatch a route.\n    \n*   In case of an error at any part among the routes, the API will immediately return the error with the index of the specific route or route step.\n    \n*   On a successful dispatch, the API returns the last route, if there are many, in the response payload.",
      },
      routing: {
        type: 'object',
        description:
          'The `routing` object allows defining the routing characteristics that should be used to generate a route when the Driver uses the in-app navigation. Only `car` mode is supported currently.',
        properties: {
          approaches: {
            type: 'string',
            description:
              'Specify the side of the road from which the route should approach the step location. When set to `unrestricted` a route can arrive at the step location from either side of the road and when set to `curb` the route will arrive at the step location only from the driving side of the region. Use a semi-colon `;` to specify approach configurations for multiple steps.',
            enum: ['`unrestricted`', '`curb`'],
          },
          avoid: {
            type: 'string',
            description:
              'Setting this will ensure the generated route avoids the object(s) specified in the input. Multiple values should be separated by a pipe (|). If `none` is provided along with other values, an error is returned as a valid route is not feasible.',
            enum: [
              '`toll`',
              '`highway`',
              '`ferry`',
              '`sharp_turn`',
              '`uturn`',
              '`left_turn`',
              '`right_turn`',
              '`service_road`',
              '`none`',
            ],
          },
          hazmat_type: {
            type: 'string',
            description:
              'Specify the type of hazardous material being carried and the dispatch service will avoid roads which are not suitable for the type of goods specified. Multiple values can be separated using a pipe operator `|` .\n\nPlease note that this parameter is effective only when `mode=truck`.',
            enum: ['`general`', '`circumstantial`', '`explosive`', '`harmful_to_water`'],
          },
          mode: {
            type: 'string',
            description: 'Specify the driving mode that the service should use to determine a route',
            enum: ['`car`'],
          },
          truck_axle_load: {
            type: 'integer',
            description:
              'Specify the total load per axle (including the weight of trailers and shipped goods) of the truck, in tonnes. When specified, the dispatched route uses only those roads which can be used by a truck to carry the specified load per axle.\n\nPlease note this parameter is effective only when `mode=truck`.',
          },
          truck_size: {
            type: 'string',
            description:
              'Specify the dimensions of a truck, in centimeters (cm), in the format of <height, width, length>. When specified, the dispatched route uses only those roads which allow trucks with specified dimensions.\n\nPlease note this parameter is effective only when `mode=truck`. Also, the maximum dimensions that can be specified are as follows:\n\nHeight = 1000 cm  \nWidth = 5000 cm  \nLength = 5000 cm',
          },
          truck_weight: {
            type: 'integer',
            description:
              'Specify the weight of the truck, including trailers and shipped goods, in kilograms (kg). When specified, the dispatched route uses only those roads which allow trucks with specified weight.\n\nPlease note this parameter is effective only when `mode=truck`. Also, the maximum weight that can be specified for a truck is 100,000 kgs.',
          },
        },
      },
    },
    required: ['key', 'driver_email', 'steps'],
    $defs: {
      route_steps_request: {
        type: 'object',
        properties: {
          arrival: {
            type: 'integer',
            description:
              'Specify the scheduled arrival time of the driver, as an UNIX timestamp in seconds, at the step. Please note that:\n\n*   Arrival time for each step should be equal to or greater than the previous step.\n    \n*   Past times can not be provided.\n    \n*   The time provided is used only for informative display on the driver app and it does not impact or get affected by the route generated.',
          },
          location: {
            type: 'array',
            description:
              'Specify the location coordinates where the steps should be performed in `[latitude, longitude]`.',
            items: {
              type: 'number',
            },
          },
          type: {
            type: 'string',
            description:
              'Specify the step type. It can belong to one of the following: `start`, `job` , `pickup`, `delivery`, `end`. A `duration` is mandatory when the step type is either `layover` or a `break`.',
            enum: ['`start`', '`job`', '`pickup`', '`delivery`', '`break`', '`layover`', '`end`'],
          },
          address: {
            type: 'string',
            description: 'Specify the postal address for the step.',
          },
          completion_mode: {
            $ref: '#/$defs/route_step_completion_mode',
          },
          document_template_id: {
            type: 'string',
            description:
              'Specify the ID of the document template to be used for collecting proof of completion for the step. If not specified, the document template specified at the route level will be used for the step. Use the [Documents API](https://docs.nextbillion.ai/docs/dispatches/documents-api) to create, read and manage the document templates.\n\nPlease note that the document template ID can not be assigned to following step types - `start`, `end`, `break`, `layover`.',
          },
          duration: {
            type: 'integer',
            description:
              'Specify the duration of the `layover` or `break` type steps, in seconds. Please note it is mandatory when step type is either "layover" or "break".',
          },
          geofence_config: {
            $ref: '#/$defs/route_step_geofence_config',
          },
          meta: {
            type: 'object',
            description:
              "An object to specify any additional details about the task to be associated with the step in the response. The information provided here will be available on the Driver's app under step details. This attribute can be used to provide context about or instructions to the driver for performing the task",
            properties: {
              customer_name: {
                type: 'string',
                description: 'Specify the name of the customer for which the step has to be performed.',
              },
              customer_phone_number: {
                type: 'string',
                description: 'Specify the phone number of the person to be contacted when at step location.',
              },
              instructions: {
                type: 'string',
                description: 'Specify custom instructions to be carried out while performing the step.',
              },
            },
          },
        },
        required: ['arrival', 'location', 'type'],
      },
      route_step_completion_mode: {
        type: 'string',
        description:
          'Specify the mode of completion to be used for the step. Currently, following values are allowed:\n\n*   `manual`: Steps must be marked as completed manually through the Driver App.\n    \n*   `geofence`: Steps are marked as completed automatically based on the entry conditions and geofence specified.\n    \n*   `geofence_manual_fallback`: Steps will be marked as completed automatically based on geofence and entry condition configurations but there will also be a provision for manually updating the status in case, geofence detection fails.',
        enum: ['`manual`', '`geofence`', '`geofence_manual_fallback`'],
      },
      route_step_geofence_config: {
        type: 'object',
        description:
          'Specify the configurations of the geofence which will be used to detect presence of the driver and complete the tasks automatically. Please note that this attribute is required when `completion_mode` is either "geofence" or "geofence\\_manual\\_fallback".',
        properties: {
          radius: {
            type: 'number',
            description:
              "Specify the radius of the cicular geofence, in meters. Once specified, the service will create a geofence with task's location as the center of the circle having the given radius. Valid values for `radius` are \\[10, 5000\\].",
          },
          type: {
            type: 'string',
            description: 'Specify the type of the geofence. Currently, `circle` is the only suppoeted value.',
            enum: ['circle'],
          },
        },
      },
    },
  },
  annotations: {},
};

export const handler = async (client: NextbillionSDK, args: Record<string, unknown> | undefined) => {
  const body = args as any;
  return asTextContentResult(await client.fleetify.routes.create(body));
};

export default { metadata, tool, handler };
